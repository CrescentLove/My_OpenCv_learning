# 答题卡识别实现beta

  ==基本实现步骤==

- [ ] 检测到答题卡
- [ ] 透视变换提取答题卡
- [ ] 从答题卡中提取每一行，每一道题
- [ ] 判断每道题的涂写区域
- [ ] 在字典中对比判断涂写区域是否一致
- [ ] 重复操作实现所有区域判断



### 〇. 准备阶段：环境搭建and包载入



```python
from imutils.perspective import four_point_transforrm			#用于透视变换提取正视图
import numpy as np
import argparse				#为py文件封装好可以选择的参数
import imutils				#opencv的便携操作包，如果用坐标切割所有区域需要先用resize标注化答题卡，这里用轮廓检测实现，不用它了
import cv2                  #即opencv-python包
```



### 一. 读取检测答题卡

高斯模糊的作用是尽量消除高频噪声，减少对边缘提取的影响。

通过canny算法提取图像边缘。



### 二. 透视变换提取

```python
cntsall = cv2.findContours(edged.copy(), cv2.RETR_EXTERNAL, 
                           cv2.CHAIN_APPROX_SIMPLE)[1]
```

从边缘图中用`findcontours`提取轮廓，只提取外轮廓，写成列表存储起来。

然后从中找到答题卡对应的轮廓。

```python
if len(cnts) > 0:    # 将轮廓按面积大小降序排序    
	cnts = sorted(cnts,key=cv2.contourArea,
                  reverse=True)        			#reverse正序   
    # 对排序后的轮廓循环处理    
	for c in cnts:        
        peri = cv2.arcLength(c, True)               #计算轮廓周长        
		approx = cv2.approxPolyDP(c, 0.02 * peri, True)  #以0.02的公差重新生成近似的轮廓
        if len(approx) == 4:
        	docCnt = approx
        	horn = cv2.convexHull(approx)
        	break
```

对原始图像和灰度图都进行四点透视变换，到这里就提取出来答题卡了。

```python
paper = four_point_transform(image, docCnt.reshape(4, 2))
warped = four_point_transform(gray, docCnt.reshape(4, 2))
```

但是我用的答题卡边缘太粗，还有内轮廓，用裁剪简单粗暴去掉。。。。



### 三. 提取答案区

大津二值化算法，然后提取区域内所有轮廓

```python
thresh_paper = cv2.threshold(warped,0,255,cv2.THRESH_BINARY_INV | cv2.THRESH_OTSU)[1]
cntsall_rect = cv2.findContours(thresh_paper, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)[1]
```

筛选轮廓，只将涂写框选出来，共计160个

```python
ques_cnts = sift_rect(cntsall_rect)
```

对160个轮廓首先按y坐标排序，然后每12个分为一组，即列表`rect_ans`，再按x坐标排序，保证轮廓是顺序排列

对每个`rect_ans`列表，再拆分成三个列表`rect_ans_per`，对应每道题的涂写框

这样就把所有涂写区域都分门别类标注好了



### 四. 判断涂写位置

用每个涂写框的区域设置一个掩膜mask，对每道题的四个涂写框分别进行与操作判断，排序得到涂写位置



### 五. 比照答案

前面设置答案字典就行，判断语句，正确涂绿，错误涂红



### 六. 其他区域处理

再议



# 补充点

### 1. 边缘检测和轮廓检测

> 边缘是极值点，而轮廓一般从边缘得来，是闭合的曲线。





### 2. `cv2.findContours()`函数【cv3和cv2区别挺大】

> 这个函数用于提取图像轮廓图
>

示例如下：`image,contours,hierarchy = cv2.findContours(img,cv2.RETR_TREE,cv2.CHAIN_APPROX_SIMPLE)`

+ 第二项参数可以选`cv2.RETR_EXTERNAL`:输出轮廓中只有外侧轮廓信息；
+ 第三项参数可以选`cv2.CHAIN_APPROX_NONE`:存储轮廓所有点的信息，相邻两个轮廓点在图象上也是相邻的；
+ 输出项有`image`图像，`contours`列表存储轮廓点信息，hierarchy。。。。。
+ 一般用`cnts`，`retr_external`和`chain_simple`的组合提取外层轮廓



### 4.大津二值化及canny边缘分割算法





# 参考文献



